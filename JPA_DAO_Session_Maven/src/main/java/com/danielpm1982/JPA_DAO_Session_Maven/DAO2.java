package com.danielpm1982.JPA_DAO_Session_Maven;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Query;
import javax.persistence.TypedQuery;

//This is the same DAO of this package, but with EntityManagerFactory and EntityManager JPA implementation.
//Hibernate implements JPA EntityManager and Hibernate specific Session, and wraps the Session with the EntityManager as an Adapter class. Session has more features, independent from the JPA specification. The xml is different, although one can get the Session from a EntityManager with the Persistence.xml, too, instead of with the Hibernate.cfg.xml. Other than that, EntityManager and Session objects are pretty much the same, and the first encapsulates the later, which has extended methods and functionalities.
//Persistence.xml must be inside META-INF folder.
//EntityManager Queries can be done without opening a transaction (after previous commit()), while Session Queries must be done with a transaction opened (between session.getTransaction.begin() and session.getTransaction().commit()). 

public class DAO2 {
	public static boolean insertStudent(Student student, EntityManagerFactory factory) { //inserts a Student and turn it managed, setting its id property with the id value generated by the dbsm. Retrieves true if saving succeeds, or false, if not.
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			em.persist(student);
			em.getTransaction().commit();
			return true;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return false;
		} finally {
			em.close();
		}
	}
	public static Student searchStudent(Long studentId, EntityManagerFactory factory) { //search a Student from a Long id argument, retrieving a managed Student object reference if that id exists, or null, if not.
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			Student student = em.find(Student.class, studentId);
			em.getTransaction().commit();
			return student;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			em.close();
		}
	}
	public static List<Student> searchStudents(String studentName, EntityManagerFactory factory) { //search all students that have partially or totally the argument name. 
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			TypedQuery<Student> query = em.createQuery("from Student where name like '%"+studentName+"%'", Student.class);
			List<Student> studentList = query.getResultList();
			em.getTransaction().commit();
			return studentList;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			em.close();
		}
	}
	public static List<Student> searchAllStudents(EntityManagerFactory factory) { //search all students. 
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			TypedQuery<Student> query = em.createQuery("from Student", Student.class);
			List<Student> studentList = query.getResultList();
			em.getTransaction().commit();
			return studentList;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			em.close();
		}
	}
	public static boolean updateStudent(Student oldStudent, Student newStudent, EntityManagerFactory factory) { // takes two mock student objects, searches for the first in the DB and, if the id exists, retrieves the actual object for being updated with the values of the other mock object (except the id attribute, which must keep the same). During the committing process of the managed actual object, and after it is updated through its sets, it is also automatically saved (or persisted) at the session and at the DB.
		oldStudent = DAO2.searchStudent(oldStudent.getId(), factory);
		if(oldStudent!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				oldStudent.setName(newStudent.getName());
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
	public static int updateStudentBulk(String studentName, String newNameForAllThatMatches, EntityManagerFactory factory) { //bulk update of ALL students that match partially or exactly the argument studentName with a new name, identical to all of them.
		if(studentName!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				Query studentQueryToUpdate = em.createQuery("update Student set name='"+newNameForAllThatMatches+"' where name like '%"+studentName+"%'");
				int affectedRows = studentQueryToUpdate.executeUpdate();
				em.getTransaction().commit();
				return affectedRows;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return 0;
			} finally {
				em.close();
			}
		} else {
			return 0;
		}
	}
	public static boolean deleteStudent(Long studentId, EntityManagerFactory factory) { //from a Long id argument, search for a Student and, if found, delete it. Returns true if successful, or false, if not.
		Student student = searchStudent(studentId, factory); //a not null result here guarantees the student exists, and retrieves it in the managed state.
		if(student!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				student = em.merge(student);
				em.remove(student);
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
	public static boolean deleteStudent(Student student, EntityManagerFactory factory) { //if the Student reference passed as argument exists in the DB (actually, its id, regardless of other attributes values), whether or not in the managed state, delete it. Returns true if successful, or false, if not. If delete is called on a non-existing instance id, Exceptions are thrown.
		if(student!=null&&searchStudent(student.getId(),factory)!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				student = em.merge(student);
				em.remove(student);
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
		
//		or refactor to:
//		return deleteStudent(student.getId(), factory);
	}
	public static boolean deleteStudentBulk(String studentName, EntityManagerFactory factory) { //bulk deletion of ALL students that match partially or exactly the argument studentName.
		if(studentName!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				Query studentListToDelete = em.createQuery("delete Student where name like '%"+studentName+"%'");
				studentListToDelete.executeUpdate();
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
	public static boolean truncateDBTable(String fullyQualifiedTableName, EntityManagerFactory factory) { //truncate the argument name table, for resetting the id generatedValue counting and eliminating all table rows.
		if(fullyQualifiedTableName!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				em.createNativeQuery("truncate table "+fullyQualifiedTableName).executeUpdate();
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
}
