package com.danielpm1982.JPA_DAO_Session_Maven;
import java.util.List;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import org.hibernate.Session;
import org.hibernate.SessionFactory;

public class DAO {
	public static boolean insertStudent(Student student, SessionFactory factory) { //inserts a Student and turn it managed, setting its id property with the id value generated by the dbsm. Retrieves true if saving succeeds, or false, if not.
		Session session = factory.getCurrentSession();
		try {
			session.getTransaction().begin();
			session.save(student);
			session.getTransaction().commit();
			return true;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return false;
		} finally {
			session.close();
		}
	}
	public static Student searchStudent(Long studentId, SessionFactory factory) { //search a Student from a Long id argument, retrieving a managed Student object reference if that id exists, or null, if not.
		Session session = factory.getCurrentSession();
		try {
			session.getTransaction().begin();
			Student student = session.get(Student.class, studentId);
			session.getTransaction().commit();
			return student;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			session.close();
		}
	}
	public static List<Student> searchStudents(String studentName, SessionFactory factory) { //search all students that have partially or totally the argument name. 
		Session session = factory.getCurrentSession();
		try {
			session.getTransaction().begin();
			TypedQuery<Student> query = session.createQuery("from Student where name like '%"+studentName+"%'", Student.class);
			List<Student> studentList = query.getResultList();
			session.getTransaction().commit();
			return studentList;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			session.close();
		}
	}
	public static List<Student> searchAllStudents(SessionFactory factory) { //search all students. 
		Session session = factory.getCurrentSession();
		try {
			session.getTransaction().begin();
			TypedQuery<Student> query = session.createQuery("from Student", Student.class);
			List<Student> studentList = query.getResultList();
			session.getTransaction().commit();
			return studentList;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			session.close();
		}
	}
	public static boolean updateStudent(Student oldStudent, Student newStudent, SessionFactory factory) { // takes two mock student objects, searches for the first in the DB and, if the id exists, retrieves the actual object for being updated with the values of the other mock object (except the id attribute, which must keep the same). During the committing process of the managed actual object, and after it is updated through its sets, it is also automatically saved (or persisted) at the session and at the DB.
		oldStudent = DAO.searchStudent(oldStudent.getId(), factory);
		if(oldStudent!=null) {
			Session session = factory.getCurrentSession();
			try {
				session.getTransaction().begin();
				oldStudent.setName(newStudent.getName());
				session.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				session.close();
			}
		} else {
			return false;
		}
	}
	public static int updateStudentBulk(String studentName, String newNameForAllThatMatches, SessionFactory factory) { //bulk update of ALL students that match partially or exactly the argument studentName with a new name, identical to all of them.
		if(studentName!=null) {
			Session session = factory.getCurrentSession();
			try {
				session.getTransaction().begin();
				Query studentQueryToUpdate = session.createQuery("update Student set name='"+newNameForAllThatMatches+"' where name like '%"+studentName+"%'");
				int affectedRows = studentQueryToUpdate.executeUpdate();
				session.getTransaction().commit();
				return affectedRows;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return 0;
			} finally {
				session.close();
			}
		} else {
			return 0;
		}
	}
	public static boolean deleteStudent(Long studentId, SessionFactory factory) { //from a Long id argument, search for a Student and, if found, delete it. Returns true if successful, or false, if not.
		Student student = searchStudent(studentId, factory); //a not null result here guarantees the student exists, and retrieves it in the managed state.
		if(student!=null) {
			Session session = factory.getCurrentSession();
			try {
				session.getTransaction().begin();
				session.delete(student);
				session.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				session.close();
			}
		} else {
			return false;
		}
	}
	public static boolean deleteStudent(Student student, SessionFactory factory) { //if the Student reference passed as argument exists in the DB (actually, its id, regardless of other attributes values), whether or not in the managed state, delete it. Returns true if successful, or false, if not. If delete is called on a non-existing instance id, Exceptions are thrown.
		if(student!=null&&searchStudent(student.getId(),factory)!=null) {
			Session session = factory.getCurrentSession();
			try {
				session.getTransaction().begin();
				session.delete(student);
				session.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				session.close();
			}
		} else {
			return false;
		}
		
//		or refactor to:
//		return deleteStudent(student.getId(), factory);
	}
	public static boolean deleteStudentBulk(String studentName, SessionFactory factory) { //bulk deletion of ALL students that match partially or exactly the argument studentName.
		if(studentName!=null) {
			Session session = factory.getCurrentSession();
			try {
				session.getTransaction().begin();
				Query studentListToDelete = session.createQuery("delete Student where name like '%"+studentName+"%'");
				studentListToDelete.executeUpdate();
				session.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				session.close();
			}
		} else {
			return false;
		}
	}
	public static boolean truncateDBTable(String fullyQualifiedTableName, SessionFactory factory) { //truncate the argument name table, for resetting the id generatedValue counting and eliminating all table rows.
		if(fullyQualifiedTableName!=null) {
			Session session = factory.getCurrentSession();
			try {
				session.getTransaction().begin();
				session.createNativeQuery("truncate table "+fullyQualifiedTableName).executeUpdate();
				session.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				session.close();
			}
		} else {
			return false;
		}
	}
}
